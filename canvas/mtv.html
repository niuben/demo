<!-- Learn about this code on MDN: https://developer.mozilla.org/zh-CN/docs/Web/API/Canvas_API/Tutorial/Basic_usage -->
<html>
<meta charset="utf-8" />

<head>
    <style>
        canvas {
            margin-top: 15px;
            border: 1px solid #000;
            display: block;
        }
    </style>
</head>

<body>    
    <canvas id="canvas" width="800" height="400"></canvas>
    <script src="js/conf.js"></script>
    <script src="js/grid.js"></script>

    <script src="js/vector.js"></script>
    <script src="js/shape.js"></script>
    <script src="js/circle.js"></script>
    <script>
        
    </script>
    <script>
        /*
* 功能：拖动两个多边形，如果两个多边形发生碰撞则显示当前已碰撞。
* 
*/

        var canvas = document.getElementById('canvas');
        var context = canvas.getContext('2d');

        var handle;
        var isMoved = false;

        function drawShapes() {
            shapes.forEach(function (shape) {
                shape.stroke(context);
                shape.fill(context);
            });
        }
        

        function windowToCanvas(e) {
            var x = e.x || e.clientX,
                y = e.y || e.clientY,
                bbox = canvas.getBoundingClientRect();

            return {
                x: x - bbox.left * (canvas.width / bbox.width),
                y: y - bbox.top * (canvas.height / bbox.height)
            };
        };

        function detectCollisions() {
            var textY = 30;
            if (shapeBeingDragged == undefined) {
                return;
            }

            
            for(var i = 0; i < shapes.length; i++){
                var shape = shapes[i];            
                if (shape == shapeBeingDragged) {
                    continue;
                }
                var obj = shapeBeingDragged.cover(shape);
                if (obj.isCover) {                        
                    
                    context.font = "18px Align";
                    context.fillStyle = shape.fillStyle;
                    context.fillText('碰撞', 20, textY);
                    textY += 40;
                    
                    // shapeBeingDragged.pause();                                    
                    // clearTimeout(handle);
                        
                        // cancelAnimationFrame(handle);                    
                        if(isMoved == true){
                            return; 
                        }
                        
                        //两个物体黏在一起
                        // shapeBeingDragged.start();
                        // shapeBeingDragged.move(-obj.minDot, -obj.minDot);
                        // shapeBeingDragged.pause();
                        
                        
                        //一个物体碰到另一个物体弹开
                        shapeBeingDragged.reflect(obj.normalAxis, context);                        
                        isMoved = true;
                    // }, 1000);

                    setTimeout(function(){                                
                        isMoved = false;
                    }, 500);

                    
                    break;
                }
            }            
            
            return;
        };

        function checkCover(dot, dot1) {
            var max = Math.max.apply(Math, dot);
            var min = Math.min.apply(Math, dot);
            var max1 = Math.max.apply(Math, dot1);
            var min1 = Math.min.apply(Math, dot1);

            if (max < min1 || max1 < min) {
                return false;
            }

            //判断重合的面积
            if(max > min1 && max < max1){
                return max - min1;
            }

            if(min > min1 && min < max1){
                return max1 - min; 
            }
            
            return max - min;
        }

        //鼠标事件
        canvas.onmousedown = function (e) {
            var pos = windowToCanvas(e);
            var x = pos.x;
            var y = pos.y;

            shapes.map(function (shape) {
                if (shape.isPointInPath(context, x, y)) {
                    shapeBeingDragged = shape;
                    mousedown = {
                        x: x,
                        y: y
                    };
                }
            });
        }

        canvas.onmousemove = function (e) {

        }

        canvas.onmouseup = function (e) {
            shapeBeingDragged = undefined;
        }


        polygonPoints.map(function (points, index) {
            var strokeStyle = polygonStrokeStyles[index];
            var fillStyle = polygonFillStyles[index];
            var shape = new Shape(strokeStyle, fillStyle);
            points.map(function (point) {
                shape.addPoint(point);
            })                     
            shapes.push(shape);
        });
        // circlePoints.map(function (points) {
        //     var point = points[0]; //圆心坐标;
        //     var r = points[1];
        //     var circle = new Circle(point.x, point.y, r);            
        //     shapes.push(circle);
        // })    
        shapeBeingDragged = shapes[shapes.length - 2];
        shapeBeingDragged.getAxis(shapes[shapes.length - 1])
                        
        function move(){
            context.clearRect(0, 0, WIDTH, HEIGHT);
            drawGrid('lightgray', 10, 10);

            shapes.map(function(shape){
                if(shape == shapeBeingDragged){
                    shapeBeingDragged.move();
                }
            });
            drawShapes();
            detectCollisions();            
            requestAnimationFrame(move);            
        }
        
        move();
        // init();

        document.getElementById("start").onclick = function () {
            //  polygonPoints = [
            //  [ new Point(220, 120), new Point(200,170),
            //   new Point(250, 250)],
            //  [ new Point(100, 100), new Point(100, 150),
            //   new Point(150, 150), new Point(150, 100)]
            // ];
            // init();
        }

    </script>
</body>

</html>