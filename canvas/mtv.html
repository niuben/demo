<!-- Learn about this code on MDN: https://developer.mozilla.org/zh-CN/docs/Web/API/Canvas_API/Tutorial/Basic_usage -->
<html>
<meta charset="utf-8" />

<head>
    <style>
        canvas {
            margin-top: 15px;
            border: 1px solid #000;
            display: block;
        }
    </style>
</head>

<body>
    <button id="start">开始</button>
    <canvas id="canvas" width="800" height="400"></canvas>
    <script src="js/conf.js"></script>
    <script src="js/vector.js"></script>
    <script src="js/shape.js"></script>
    <script src="js/circle.js"></script>
    <script>
        function drawGrid(color, stepx, stepy) {
            context.save();

            context.shadowColor = undefined;
            context.shadowBlur = 0;
            context.shadowOffsetX = 0;
            context.shadowOffsetY = 0;

            context.strokeStyle = color;
            context.fillStyle = '#ffffff';
            context.lineWidth = 0.5;
            context.fillRect(0, 0, context.canvas.width, context.canvas.height);

            for (var i = stepx + 0.5; i < context.canvas.width; i += stepx) {
                context.beginPath();
                context.moveTo(i, 0);
                context.lineTo(i, context.canvas.height);
                if (Math.floor(i) % 50 == 0) { context.strokeText(Math.floor(i - 0.5), i - 10 / 2, 10); }
                context.stroke();
            }

            for (var i = stepy + 0.5; i < context.canvas.height; i += stepy) {
                context.beginPath();
                context.moveTo(0, i);
                context.lineTo(context.canvas.width, i);
                if (Math.floor(i) % 50 == 0) { context.strokeText(Math.floor(i - 0.5), 0, i); }
                context.stroke();
            }

            context.restore();
        }

    </script>
    <script>
        /*
* 功能：拖动两个多边形，如果两个多边形发生碰撞则显示当前已碰撞。
* 
*/

        var canvas = document.getElementById('canvas');
        var context = canvas.getContext('2d');

        var handle;

        function drawShapes() {
            shapes.forEach(function (shape) {
                shape.stroke(context);
                shape.fill(context);
            });
        }
        

        function windowToCanvas(e) {
            var x = e.x || e.clientX,
                y = e.y || e.clientY,
                bbox = canvas.getBoundingClientRect();

            return {
                x: x - bbox.left * (canvas.width / bbox.width),
                y: y - bbox.top * (canvas.height / bbox.height)
            };
        };

        function detectCollisions() {
            var textY = 30;
            if (shapeBeingDragged) {
                shapes.forEach(function (shape) {
                    if (shape !== shapeBeingDragged) {
                        var obj = shapeBeingDragged.cover(shape);
                        if (obj.isCover) {

                            shapeBeingDragged.pause();

                            // clearTimeout(handle);
                            cancelAnimationFrame(handle);
                            setTimeout(function(){
                                console.log("a");
                                shapeBeingDragged.start();
                                shapeBeingDragged.move(-obj.minDot, -obj.minDot);
                                shapeBeingDragged.pause();
                            }, 1000);

                            context.font = "18px Align";
                            context.fillStyle = shape.fillStyle;
                            context.fillText('碰撞', 20, textY);
                            textY += 40;
                        }
                    }
                });
            }
        };

        function checkCover(dot, dot1) {
            var max = Math.max.apply(Math, dot);
            var min = Math.min.apply(Math, dot);
            var max1 = Math.max.apply(Math, dot1);
            var min1 = Math.min.apply(Math, dot1);

            if (max < min1 || max1 < min) {
                return false;
            }

            //判断重合的面积
            if(max > min1 && max < max1){
                return max - min1;
            }

            if(min > min1 && min < max1){
                return max1 - min; 
            }
            
            return max - min;
        }

        //鼠标事件
        canvas.onmousedown = function (e) {
            var pos = windowToCanvas(e);
            var x = pos.x;
            var y = pos.y;

            shapes.map(function (shape) {
                if (shape.isPointInPath(context, x, y)) {
                    shapeBeingDragged = shape;
                    mousedown = {
                        x: x,
                        y: y
                    };
                }
            });
        }

        canvas.onmousemove = function (e) {

        }

        canvas.onmouseup = function (e) {
            shapeBeingDragged = undefined;
        }


        polygonPoints.map(function (points, index) {
            var strokeStyle = polygonStrokeStyles[index];
            var fillStyle = polygonFillStyles[index];
            var shape = new Shape(strokeStyle, fillStyle);
            points.map(function (point) {
                shape.addPoint(point);
            })                     
            shapes.push(shape);
        });
        // circlePoints.map(function (points) {
        //     var point = points[0]; //圆心坐标;
        //     var r = points[1];
        //     var circle = new Circle(point.x, point.y, r);            
        //     shapes.push(circle);
        // })    
        shapeBeingDragged = shapes[shapes.length - 1];
        shapeBeingDragged.getAxis(shapes[shapes.length - 2])
        

                
        function move(){
            context.clearRect(0, 0, WIDTH, HEIGHT);
            drawGrid('lightgray', 10, 10);

            shapes.map(function(shape){
                if(shape == shapeBeingDragged){
                    shapeBeingDragged.move();
                }
            });
            drawShapes();
            detectCollisions();
            handle = requestAnimationFrame(move);
        }
        
        move();
        // init();

        document.getElementById("start").onclick = function () {
            //  polygonPoints = [
            //  [ new Point(220, 120), new Point(200,170),
            //   new Point(250, 250)],
            //  [ new Point(100, 100), new Point(100, 150),
            //   new Point(150, 150), new Point(150, 100)]
            // ];
            // init();
        }

    </script>
</body>

</html>